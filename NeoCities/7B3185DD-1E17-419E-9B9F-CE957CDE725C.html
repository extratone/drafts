<!DOCTYPE html>
<html dir="auto">

<head>
  <title>UIKeyCommand   NSHipster</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    @charset "utf-8";

    :root {
      --main-bg-color: #000056;
      --main-color: #ffe8bd;
      --alternate-bg-color: #1c0021;
      --alternate-color: #fff4e6;
      --main-border-color: #f43f32;
        --link-color: #36fd63;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --main-bg-color: #fff4e6;
        --main-color: #00006b;
        --alternate-bg-color: #fffdeb;
        --alternate-color: #1c0021;
        --main-border-color: #f43f32;
          --link-color: #ff0000;
      }
    }

    html {
      font-size: 100%;
      font-family: -apple-system, BlinkMacSystemFont, "helvetica neue", helvetica, roboto, noto, "segoe ui", arial, sans-serif;
      line-height: 1.4;
    }

    body {
      margin: 0;
      padding: 1em;
      background-color: var(--main-bg-color);
      color: var(--main-color);
    }

    @media (max-device-width: 480px) {}

    @media (min-device-width: 481px) {
      body {
        margin: auto;
        max-width: 600px;
      }
    }

    blockquote {
      font-style: italic;
      margin: 1.5em 2em;
      padding: 1em;
      background-color: var(--alternate-bg-color);
      color: var(--alternate-color);
    }

    a {
      color: var(--link-color);
    }
    pre {
      display: block;
      overflow: scroll;
      width: 100%;
      background-color: var(--alternate-bg-color);
      padding: .5em 1em;
      margin: 1em 0;
    }

    code {
      background-color: var(--alternate-bg-color);
      color: var(--alternate-color);
      font-family: Menlo, Courier, sans-serif;
      padding: 2px 3px;
    }

    table {
      margin: 1.5em 0;
      border: 1px solid var(--main-border-color);
      border-collapse: collapse;
    }

    th {
      padding: .25em .5em;
      background: var(--alternate-bg-color);
      border: 1px solid var(--main-border-color);
    }

    td {
      padding: .25em .5em;
      border: 1px solid var(--main-border-color);
    }

    img {
      max-width: 90%;
    }
  </style>
</head>

<body>
  <h1>UIKeyCommand | NSHipster</h1>

<hr />

<h2>title: UIKeyCommand
author: Nate Cook
category: Cocoa
excerpt: &#8220;As part of the push for greater productivity on the iPad, iOS 9 adds <em>Discoverability</em>, an overlay showing the currently available key commands inside an app. This small change suddenly makes key commands far more viable on the iPad and, with it, makes <code>UIKeyCommand</code> a necessary addition to your app.&#8221;
status:
swift: 2.0</h2>

<p>Adding a new feature to a product is always a tradeoff. Will the added utility of a new feature be enough to offset the added complexity? Shortcuts would seem to side-step this issue—after all, they&#8217;re simply a quicker alternative for features already in your app. But that creates another dilemma: what if a new feature is added and no one knows it&#8217;s there?</p>

<p>When key commands for external keyboards debuted in iOS 7, there was no intrinsic way to learn of their existence. Unlike in OS X, where a user can gradually discover shortcuts for the menu items they use most often, an iOS app had few ways to communicate what key commands are available. Initial tours flash by and fade from memory; help screens are hidden out of sight. Without a way to make shortcuts visible in a timely and relevant manner, users were sure to miss out on useful features that developers had taken the time to implement.</p>

<p>No longer. As part of the push for greater productivity on the iPad, iOS 9 adds <em>Discoverability</em>, an overlay showing the currently available key commands inside an app. This small change suddenly makes key commands far more viable on the iPad and, with it, makes <code>UIKeyCommand</code> a necessary addition to your app.</p>

<hr />

<h2><code>UIKeyCommand</code></h2>

<p>The <code>UIKeyCommand</code> class is in fact quite simple, with only four properties to configure:</p>

<ul>
<li><p><code>input</code>: The character of the key you&#8217;d like to recognize, or the correct constant for the arrow and escape keys, which do not have characters themselves. The available constants are:</p>

<ul>
<li><code>UIKeyInputUpArrow</code></li>
<li><code>UIKeyInputDownArrow</code></li>
<li><code>UIKeyInputLeftArrow</code></li>
<li><code>UIKeyInputRightArrow</code></li>
<li><code>UIKeyInputEscape</code></li>
</ul></li>
<li><p><code>modifierFlags</code>: One or more <code>UIKeyModifierFlags</code>, describing the modifier keys that should be pressed in combination with <code>input</code>:</p>

<ul>
<li><code>.Command</code>, <code>.Alternate</code>, <code>.Shift</code>, <code>.Control</code>: The Command, Option, Shift, and Control keys, respectively.</li>
<li><code>.NumericPad</code>: Indicates that <code>input</code> should come from the numeric keypad rather than the top row of the standard keyboard.</li>
<li><code>.AlphaShift</code>: Indicates that the CapsLock key should be <em>pressed</em> as part of the combination, rather than just engaged.</li>
</ul></li>
<li><p><code>action</code>: The selector to call when the key command is invoked, called with a <code>UIKeyCommand</code> as its only argument. The key event will travel up the responder chain until a matching selector is found.</p></li>
<li><p><code>discoverabilityTitle</code> <em>(iOS 9 only)</em>: An optional label to display for the key command in the Discoverability layover. Only key commands with a title set will be listed.</p></li>
</ul>

<h2>Responding to Key Commands</h2>

<p>Enabling key commands is as simple as providing an array of <code>UIKeyCommand</code> instances somewhere in the responder chain. Text inputs are automatically first responders, but perhaps more usefully, a view controller can respond to key commands by implementing <code>canBecomeFirstResponder()</code>:</p>

<pre><code class="swift">override func canBecomeFirstResponder() -&gt; Bool {
    return true
}
</code></pre>

<pre><code class="objc">- (BOOL)canBecomeFirstResponder {
    return YES;
}
</code></pre>

<p>Next, provide a list of available key commands via the <code>keyCommands</code> property:</p>

<pre><code class="swift">override var keyCommands: [UIKeyCommand]? {
    return [
        UIKeyCommand(input: &quot;1&quot;, modifierFlags: .Command, action: &quot;selectTab:&quot;, discoverabilityTitle: &quot;Types&quot;),
        UIKeyCommand(input: &quot;2&quot;, modifierFlags: .Command, action: &quot;selectTab:&quot;, discoverabilityTitle: &quot;Protocols&quot;),
        UIKeyCommand(input: &quot;3&quot;, modifierFlags: .Command, action: &quot;selectTab:&quot;, discoverabilityTitle: &quot;Functions&quot;),
        UIKeyCommand(input: &quot;4&quot;, modifierFlags: .Command, action: &quot;selectTab:&quot;, discoverabilityTitle: &quot;Operators&quot;),
            
        UIKeyCommand(input: &quot;f&quot;, modifierFlags: [.Command, .Alternate], action: &quot;search:&quot;, discoverabilityTitle: &quot;Find…&quot;),
    ]
}

&lt;#...#&gt;

func selectTab(sender: UIKeyCommand) {
    let selectedTab = sender.input
    &lt;#...#&gt;
}
</code></pre>

<pre><code class="objc">- (NSArray&lt;UIKeyCommand *&gt;*)keyCommands {
    return @[
        [UIKeyCommand keyCommandWithInput:@&quot;1&quot; modifierFlags:UIKeyModifierCommand action:@selector(selectTab:) discoverabilityTitle:@&quot;Types&quot;],
        [UIKeyCommand keyCommandWithInput:@&quot;2&quot; modifierFlags:UIKeyModifierCommand action:@selector(selectTab:) discoverabilityTitle:@&quot;Protocols&quot;],
        [UIKeyCommand keyCommandWithInput:@&quot;3&quot; modifierFlags:UIKeyModifierCommand action:@selector(selectTab:) discoverabilityTitle:@&quot;Functions&quot;],
        [UIKeyCommand keyCommandWithInput:@&quot;4&quot; modifierFlags:UIKeyModifierCommand action:@selector(selectTab:) discoverabilityTitle:@&quot;Operators&quot;],

        [UIKeyCommand keyCommandWithInput:@&quot;f&quot; 
                            modifierFlags:UIKeyModifierCommand | UIKeyModifierAlternate 
                                   action:@selector(search:) 
                     discoverabilityTitle:@&quot;Find…&quot;]
    ];
}

&lt;#...#&gt;

- (void)selectTab:(UIKeyCommand *)sender {
    NSString *selectedTab = sender.input;
    &lt;#...#&gt;
}
</code></pre>

<p>In the Discoverability layover, accessed by holding down the Command key, key commands are listed in the order you specified:</p>

<figure>
<img src="{%" alt="Discoverability Layover" />
<figcaption>Discoverability Layover</figcaption>
</figure>

<p><em>Voila!</em> Secrets, revealed!</p>

<h3>Context Sensitivity</h3>

<p>The <code>keyCommands</code> property is accessed whenever a key pressed, making it possible to provide context-sensitive responses depending on the state of your application. While this is similar to the way a menu item and its active/inactive state are configured in OS X, the recommendation for iOS is to omit inactive commands completely—that is, there are no grayed out commands in the Discoverability layover.</p>

<p>Here, a set of commands that are available to logged in users of an app are included only when appropriate:</p>

<pre><code class="swift">let globalKeyCommands = [UIKeyCommand(input:...), ...]
let loggedInUserKeyCommands = [UIKeyCommand(input:...), ...]

override var keyCommands: [UIKeyCommand]? {
    if isLoggedInUser() {
        return globalKeyCommands + loggedInUserKeyCommands
    } else {
        return globalKeyCommands
    }
}
</code></pre>

<hr />

<p>Although we don&#8217;t take shortcuts when creating our apps, that doesn&#8217;t mean our users won&#8217;t find shortcuts useful. Adding key commands lets control of your app shift from the screen to the keyboard—your users will love the option.</p>

</body>

<footer>
<p><a href="https://twitter.com/NeoYokel">Twitter</a> - <a href="https://mastodon.social/@DavidBlue">Mastodon</a> - <a href="https://t.me/davidblue">Telegram</a> - <a href="drafts://open?uuid=7B3185DD-1E17-419E-9B9F-CE957CDE725C">Local</a></p>
</footer>
</html>